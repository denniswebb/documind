#!/bin/bash

# DocuMind Documentation Generator
# Master documentation generation script that orchestrates the entire pipeline

set -euo pipefail

# Source utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/utils.sh"

# Script metadata
SCRIPT_NAME="generate-docs"
SCRIPT_VERSION="1.0.0"

# Default configuration
DEFAULT_MODE="update"
DEFAULT_OUTPUT_DIR="docs"
DEFAULT_BUDGET=4000

# Usage information
show_generate_usage() {
    show_usage "$SCRIPT_NAME" \
        "Orchestrate complete documentation generation pipeline" \
        "$SCRIPT_NAME [OPTIONS] [MODE]" \
        "  $SCRIPT_NAME bootstrap                    # Generate complete docs from scratch
  $SCRIPT_NAME update                       # Update existing documentation
  $SCRIPT_NAME expand concept               # Expand specific concept documentation
  $SCRIPT_NAME analyze integration          # Document external integrations
  $SCRIPT_NAME --budget=500 --split bootstrap    # Generate with token splitting
  $SCRIPT_NAME --dry-run update             # Preview changes without writing
  $SCRIPT_NAME --output=public update       # Custom output directory"

    echo
    echo -e "$(get_color neon_cyan)GENERATION MODES:$(get_color reset)"
    echo "  bootstrap    Generate complete documentation from codebase analysis"
    echo "  update       Update existing documentation sections"
    echo "  expand       Expand specific concepts with detailed explanations"
    echo "  analyze      Analyze and document external service integrations"
    echo "  index        Rebuild navigation index and cross-references"
    echo "  search       Search existing documentation"
    echo
    echo -e "$(get_color neon_cyan)PIPELINE OPTIONS:$(get_color reset)"
    echo "  --split              Enable automatic markdown splitting for large files"
    echo "  --budget=N           Token budget for splitting (default: $DEFAULT_BUDGET)"
    echo "  --replace-original   Move original files to .original after splitting"
    echo "  --validate           Validate all generated content"
    echo "  --check-deps         Check dependencies before starting"
    echo "  --dry-run            Preview changes without writing files"
    echo "  --cleanup            Clean up temporary files after generation"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    # Check if DocuMind is initialized
    if [[ ! -d "$DOCUMIND_ROOT_DIR/.documind" ]]; then
        die "DocuMind not initialized. Run 'documind init' first."
    fi

    # Check dependencies if requested
    if command -v "$SCRIPT_DIR/check-dependencies" >/dev/null; then
        local dep_result
        if ! dep_result=$("$SCRIPT_DIR/check-dependencies" --summary 2>&1); then
            log_warning "Some dependencies are missing:"
            echo "$dep_result"
            log_info "Run '$SCRIPT_DIR/check-dependencies --fix' to install missing packages"

            # Continue with warning unless critical dependencies are missing
            if ! command_exists node || ! command_exists npm; then
                die "Critical dependencies missing: Node.js and npm are required"
            fi
        fi
    fi

    log_debug "Prerequisites check completed"
}

# Bootstrap complete documentation
bootstrap_documentation() {
    local output_dir="$1"
    local dry_run="$2"
    local split="$3"
    local validate="$4"
    local budget="$5"
    local replace_original="$6"

    log_header "🚀 Bootstrapping Complete Documentation"

    # Create output directory structure
    if [[ "$dry_run" != "true" ]]; then
        safe_mkdir "$output_dir"
        safe_mkdir "$output_dir/api"
        safe_mkdir "$output_dir/guides"
        safe_mkdir "$output_dir/concepts"
        safe_mkdir "$output_dir/integrations"
    fi

    # Generate main README if it doesn't exist
    local readme_file="$output_dir/README.md"
    if [[ ! -f "$readme_file" || "$dry_run" == "true" ]]; then
        log_info "Generating main README..."

        if [[ "$dry_run" != "true" ]]; then
            generate_main_readme "$readme_file"
        else
            log_info "Would generate: $readme_file"
        fi
    fi

    # Generate API documentation
    log_info "Generating API documentation..."
    if [[ "$dry_run" != "true" ]]; then
        generate_api_docs "$output_dir/api"
    else
        log_info "Would generate API docs in: $output_dir/api"
    fi

    # Generate getting started guide
    log_info "Generating getting started guide..."
    if [[ "$dry_run" != "true" ]]; then
        generate_getting_started "$output_dir/guides/getting-started.md"
    else
        log_info "Would generate: $output_dir/guides/getting-started.md"
    fi

    # Handle splitting if enabled
    if [[ "$split" == "true" ]]; then
        handle_documentation_splitting "$output_dir" "$budget" "$dry_run" "$replace_original"
    fi

    # Validate if requested
    if [[ "$validate" == "true" ]]; then
        validate_generated_docs "$output_dir"
    fi

    log_success "Documentation bootstrap completed"
}

# Update existing documentation
update_documentation() {
    local target="$1"
    local output_dir="$2"
    local dry_run="$3"
    local split="$4"
    local validate="$5"
    local budget="$6"
    local replace_original="$7"

    log_header "🔄 Updating Documentation"

    if [[ ! -d "$output_dir" ]]; then
        log_warning "Documentation directory not found, bootstrapping instead..."
        bootstrap_documentation "$output_dir" "$dry_run" "$split" "$validate" "$budget" "$replace_original"
        return
    fi

    # Update specific section if specified
    if [[ -n "$target" ]]; then
        log_info "Updating section: $target"
        update_documentation_section "$target" "$output_dir" "$dry_run"
    else
        # Update all sections
        log_info "Updating all documentation sections..."

        # Update README
        if [[ -f "$output_dir/README.md" ]]; then
            log_info "Updating main README..."
            if [[ "$dry_run" != "true" ]]; then
                update_main_readme "$output_dir/README.md"
            fi
        fi

        # Update API docs
        if [[ -d "$output_dir/api" ]]; then
            log_info "Updating API documentation..."
            if [[ "$dry_run" != "true" ]]; then
                update_api_docs "$output_dir/api"
            fi
        fi

        # Update guides
        if [[ -d "$output_dir/guides" ]]; then
            log_info "Updating guides..."
            if [[ "$dry_run" != "true" ]]; then
                update_guides "$output_dir/guides"
            fi
        fi
    fi

    # Handle splitting if enabled
    if [[ "$split" == "true" ]]; then
        handle_documentation_splitting "$output_dir" "$budget" "$dry_run" "$replace_original"
    fi

    # Validate if requested
    if [[ "$validate" == "true" ]]; then
        validate_generated_docs "$output_dir"
    fi

    log_success "Documentation update completed"
}

# Handle automatic documentation splitting
handle_documentation_splitting() {
    local output_dir="$1"
    local budget="$2"
    local dry_run="$3"
    local replace_original="$4"

    log_info "Checking for files that need splitting (budget: $budget tokens)..."

    if ! command -v "$SCRIPT_DIR/split-markdown" >/dev/null; then
        log_warning "split-markdown utility not available, skipping splitting"
        return
    fi

    # Find markdown files that exceed budget
    local files_to_split=()
    while IFS= read -r -d '' file; do
        if [[ -f "$file" ]]; then
            local token_count
            if command -v "$SCRIPT_DIR/token-count" >/dev/null; then
                token_count=$(cat "$file" | "$SCRIPT_DIR/token-count" --format=summary 2>/dev/null || echo "0")

                if [[ $token_count -gt $budget ]]; then
                    files_to_split+=("$file")
                    log_info "File exceeds budget: $(basename "$file") ($token_count tokens)"
                fi
            fi
        fi
    done < <(find "$output_dir" -name "*.md" -print0 2>/dev/null)

    # Split files that exceed budget
    for file in "${files_to_split[@]}"; do
        local file_base
        file_base=$(basename "$file" .md)
        local split_dir="$output_dir/${file_base}_split"

        log_info "Splitting: $(basename "$file")"

        if [[ "$dry_run" != "true" ]]; then
            if "$SCRIPT_DIR/split-markdown" --budget="$budget" --output="$split_dir" --index "$file"; then
                log_success "Split $(basename "$file") into chunks"

                # Move original file to backup only if replace_original flag is set
                if [[ "$replace_original" == "true" ]]; then
                    mv "$file" "${file}.original"
                    log_debug "Moved original file to ${file}.original"

                    # Create redirect file
                    create_split_redirect "$file" "$split_dir"
                else
                    log_debug "Original file preserved (use --replace-original to move to backup)"
                fi
            else
                log_warning "Failed to split $(basename "$file")"
            fi
        else
            log_info "Would split: $file -> $split_dir"
            if [[ "$replace_original" == "true" ]]; then
                log_info "Would move original to: ${file}.original"
            fi
        fi
    done
}

# Create redirect file for split documents
create_split_redirect() {
    local original_file="$1"
    local split_dir="$2"

    cat > "$original_file" << EOF
# $(basename "$original_file" .md)

This document has been split into multiple parts for better manageability.

**📖 [View Complete Documentation]($(basename "$split_dir")/index.md)**

## Quick Links

EOF

    # Add links to main chunks
    if [[ -f "$split_dir/index.md" ]]; then
        grep -E "^\- \[" "$split_dir/index.md" >> "$original_file" 2>/dev/null || true
    fi

    cat >> "$original_file" << EOF

---

*This document was automatically split using DocuMind's token budget management.*
EOF
}

# Generate main README
generate_main_readme() {
    local readme_file="$1"

    # Get project name from package.json or directory
    local project_name="Project"
    if [[ -f "$DOCUMIND_ROOT_DIR/package.json" ]]; then
        project_name=$(jq -r '.name // "Project"' "$DOCUMIND_ROOT_DIR/package.json" 2>/dev/null || echo "Project")
    fi

    local project_desc="A software project with comprehensive documentation."
    if [[ -f "$DOCUMIND_ROOT_DIR/package.json" ]]; then
        project_desc=$(jq -r '.description // "A software project with comprehensive documentation."' "$DOCUMIND_ROOT_DIR/package.json" 2>/dev/null || echo "A software project with comprehensive documentation.")
    fi

    cat > "$readme_file" << EOF
# $project_name

$project_desc

## 📚 Documentation

- [Getting Started](guides/getting-started.md) - Quick start guide
- [API Reference](api/README.md) - Complete API documentation
- [Concepts](concepts/README.md) - Core concepts and explanations
- [Integrations](integrations/README.md) - External service integrations

## 🚀 Quick Start

1. Install dependencies
2. Configure your environment
3. Run the application

For detailed instructions, see [Getting Started](guides/getting-started.md).

## 📖 Documentation Structure

\`\`\`
docs/
├── README.md              # This file
├── guides/                # User guides and tutorials
│   ├── getting-started.md # Quick start guide
│   └── ...
├── api/                   # API documentation
│   ├── README.md         # API overview
│   └── ...
├── concepts/              # Core concepts
│   ├── README.md         # Concepts overview
│   └── ...
└── integrations/          # External integrations
    ├── README.md         # Integrations overview
    └── ...
\`\`\`

## 🔧 Contributing

This documentation is generated and maintained using [DocuMind](https://github.com/denniswebb/documind).

To update documentation:
1. Make changes to your code and comments
2. Run documentation generation
3. Review and commit changes

---

*Documentation generated with DocuMind*
EOF

    log_debug "Generated main README: $readme_file"
}

# Placeholder functions for actual content generation
generate_api_docs() {
    local api_dir="$1"
    safe_mkdir "$api_dir"

    # This would integrate with actual API documentation tools
    log_debug "API documentation generation placeholder"
}

generate_getting_started() {
    local guide_file="$1"
    safe_mkdir "$(dirname "$guide_file")"

    # This would generate based on actual project structure
    log_debug "Getting started guide generation placeholder"
}

update_main_readme() {
    local readme_file="$1"
    log_debug "README update placeholder"
}

update_api_docs() {
    local api_dir="$1"
    log_debug "API docs update placeholder"
}

update_guides() {
    local guides_dir="$1"
    log_debug "Guides update placeholder"
}

update_documentation_section() {
    local section="$1"
    local output_dir="$2"
    local dry_run="$3"

    log_debug "Section update placeholder: $section"
}

# Validate generated documentation
validate_generated_docs() {
    local docs_dir="$1"

    log_info "Validating generated documentation..."

    local validation_errors=0

    # Check for required files
    local required_files=("README.md")
    for file in "${required_files[@]}"; do
        local full_path="$docs_dir/$file"
        if [[ ! -f "$full_path" ]]; then
            log_error "Required file missing: $file"
            validation_errors=$((validation_errors + 1))
        elif [[ ! -s "$full_path" ]]; then
            log_error "Required file is empty: $file"
            validation_errors=$((validation_errors + 1))
        fi
    done

    # Validate YAML manifests if they exist
    if command -v "$SCRIPT_DIR/validate-yaml" >/dev/null; then
        local yaml_files
        yaml_files=$(find "$docs_dir" -name "*.yaml" -o -name "*.yml" 2>/dev/null || true)

        if [[ -n "$yaml_files" ]]; then
            log_info "Validating YAML manifests..."
            if ! echo "$yaml_files" | "$SCRIPT_DIR/validate-yaml" --stdin --summary; then
                validation_errors=$((validation_errors + 1))
            fi
        fi
    fi

    # Check token budgets if enabled
    if command -v "$SCRIPT_DIR/token-count" >/dev/null; then
        log_info "Checking token budgets..."
        local large_files
        large_files=$(find "$docs_dir" -name "*.md" -exec "$SCRIPT_DIR/token-count" --budget=5000 --format=summary {} \; 2>/dev/null | grep -v "within budget" || true)

        if [[ -n "$large_files" ]]; then
            log_warning "Some files may benefit from splitting:"
            echo "$large_files"
        fi
    fi

    if [[ $validation_errors -eq 0 ]]; then
        log_success "Documentation validation passed"
        return 0
    else
        log_error "Documentation validation failed with $validation_errors errors"
        return 1
    fi
}

# Main function
main() {
    # Individual variables for bash 3.2 compatibility
    local help="false"
    local debug="false"
    local quiet="false"
    local mode="$DEFAULT_MODE"
    local output="$DEFAULT_OUTPUT_DIR"
    local budget="$DEFAULT_BUDGET"
    local split="false"
    local replace_original="false"
    local validate="false"
    local check_deps="false"
    local dry_run="false"
    local cleanup="false"
    local target=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                help="true"
                shift
                ;;
            -v|--verbose|--debug)
                DOCUMIND_DEBUG=true
                debug="true"
                shift
                ;;
            -q|--quiet)
                DOCUMIND_QUIET=true
                quiet="true"
                shift
                ;;
            --output=*|-o=*)
                output="${1#*=}"
                shift
                ;;
            --budget=*)
                budget="${1#*=}"
                shift
                ;;
            --split)
                split="true"
                shift
                ;;
            --replace-original)
                replace_original="true"
                shift
                ;;
            --validate)
                validate="true"
                shift
                ;;
            --check-deps)
                check_deps="true"
                shift
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            --cleanup)
                cleanup="true"
                shift
                ;;
            bootstrap|update|expand|analyze|index|search)
                mode="$1"
                shift
                # Next argument might be a target
                if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
                    target="$1"
                    shift
                fi
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                if [[ -z "$target" ]]; then
                    target="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done

    # Handle help
    if [[ "$help" == "true" ]]; then
        show_generate_usage
        exit 0
    fi

    # Initialize DocuMind paths
    init_documind_paths

    # Check prerequisites
    if [[ "$check_deps" == "true" ]]; then
        check_prerequisites
    fi

    # Dry run notification
    if [[ "$dry_run" == "true" ]]; then
        log_info "🏃 Dry run mode - no files will be modified"
    fi

    # Execute mode
    case "$mode" in
        bootstrap)
            bootstrap_documentation "$output" "$dry_run" "$split" "$validate" "$budget" "$replace_original"
            ;;
        update)
            update_documentation "$target" "$output" "$dry_run" "$split" "$validate" "$budget" "$replace_original"
            ;;
        expand|analyze|index|search)
            log_warning "Mode '$mode' not yet implemented"
            ;;
        *)
            die "Unknown mode: $mode"
            ;;
    esac

    # Cleanup if requested
    if [[ "$cleanup" == "true" ]]; then
        log_info "Cleaning up temporary files..."
        find "$output" -name "*.tmp" -delete 2>/dev/null || true
        find "$output" -name "*.backup-*" -delete 2>/dev/null || true
    fi

    log_success "Documentation generation completed"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi